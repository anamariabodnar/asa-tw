<?php if ( ! defined('BASEPATH')) exit('No direct script access allowed');

class Exploit extends CI_Model{

	private   $exploitdb_dir;     //directory where exploits are stored.
    protected $db;                // dbatabase connection object
    protected $header;            // Curl Header used only to debug
    protected $file;              // SPLFileInfo object with actual expÄºoit file in proccess
    protected $log_file;          // file to logging all events 
    protected $fh_log;            // Resource: The logfile handled by  (fopen)
    protected $new_exploits;      // flag that saves if a new exploit has been added

    function __construct() {
    	parent:: __construct();
        //this->exploitdb_dir = "./platforms/";
        $this->log_file =  "exploitdb.log";
        $this->dbconnect();
    }

    function getRows($params = array()){
    }
    /**
     * Make a connection to a database, and set it to $this->db
     * @param  String $dbtype String to select your prefered database
     */
    private function dbconnect() {
    	global $db;
        try {
              $username = 'asa_user';

              // Oracle DB user password
              $password = 'asa_user';

              // Oracle DB connection string
              $connection_string = 'localhost/xe';

              //Connect to an Oracle database
              $this->db = oci_connect($username,
                                      $password,
                                      $connection_string
                                      );
        } catch (PDOException $e) {

          $this->log('Error connecting database: '. $e->getMessage());

            die($e->getMessage() . "\n");
        }
    }
    /*
    ** Get all exploits from database
    */
    public function get_filtered_exploits($filter)
    {
      global $db;
      $query = "SELECT ID, TITLE, CREATED_AT, PLATFORM, AUTHOR FROM EXPLOITS WHERE TITLE LIKE '%".$filter."%'";
      $result = oci_parse($this->db,$query);
      oci_execute($result);
      $counter = 0;
      $exploits = array();
      while ($row = oci_fetch_array($result, OCI_RETURN_NULLS+OCI_ASSOC)) {
        $exploit = array();
        $counter=0;
        foreach ($row as $item) {
          switch($counter) {
            case 0:
              $exploit['id'] = $item;
              break;
            case 1:
              $exploit['title'] = $item;
              break;
            case 2:
              $exploit['date'] = $item;
              break;
            case 3:
              $exploit['platform'] = $item;
              break;
            case 4:
              $exploit['author'] = $item;
              array_push($exploits, $exploit);
              break;
          }
          $counter = $counter+1;
        }
      }
    return $exploits;
    }

    /*
    ** Get code from exploit id
    */
    public function get_code($id)
    {
      global $db;
      $query = "SELECT CODE FROM EXPLOITS WHERE ID = " . $id;
      $result = oci_parse($this->db,$query);
      oci_execute($result);
      $exploit = array();
      while ($row = oci_fetch_array($result, OCI_RETURN_NULLS+OCI_ASSOC)) {
        foreach ($row as $item) {
          $exploit['code'] = $item;
        }
      }
    return $exploit;
    }
    /*
    ** Get the exploits in a particular range from lowerbound to upperbound from ordered by latest from database
    */
    public function get_exploits($lowerbound, $upperbound)
    {
    	global $db;
    	$query = "SELECT ID, TITLE, CREATED_AT, PLATFORM, AUTHOR FROM 
									(SELECT ID, TITLE, CREATED_AT, PLATFORM, AUTHOR, ROW_NUMBER() OVER (ORDER BY CREATED_AT DESC) r FROM EXPLOITS) 
									WHERE r BETWEEN " . $lowerbound . ' AND ' . $upperbound;
  		$result = oci_parse($this->db,$query);
  		oci_execute($result);
  		$counter = 0;
  		$exploits = array();
  		while ($row = oci_fetch_array($result, OCI_RETURN_NULLS+OCI_ASSOC)) {
  			$exploit = array();
  			$counter=0;
  			foreach ($row as $item) {
  				switch($counter) {
  					case 0:
  						$exploit['id'] = $item;
  						break;
  					case 1:
  						$exploit['title'] = $item;
  						break;
  					case 2:
  						$exploit['date'] = $item;
  						break;
  					case 3:
  						$exploit['platform'] = $item;
  						break;
  					case 4:
  						$exploit['author'] = $item;
  						array_push($exploits, $exploit);
  						break;
  				}
  				$counter = $counter+1;
  			}
  		}
		return $exploits;
    }

    /*
     * Insert user information
     */
    /**
     * Insert the exploit on database
     * The $obj is returned by getExploitInfo()
     * @param  StdClass $obj a Object contain 
     *     $obj->ID     : Id of Exploit on exploit0-db.com
     *     $obj->title  : The title of Exploit
     *     $obj->url    : URL to Exploit om exploit-db.com
     *     $obj->CVE    : The VCE data
     *     $obj->OSVDB  : OSVDB-ID of exploit
     *     $obj->author : Exploit  Author
     *     $obj->published : exploit published date
     *     $ojj->file   : path to exploit
     * @throws A Exception if fail 
     */
    private function insert_exploit($id, $path, $title, $created_at, $author, $platform, $code) {

        try {
            $website = 2;
            $sql = "INSERT INTO exploits(
                  id,
                  path,
                  title,
                  created_at,
                  author, 
                  platform,
                  code) VALUES (
                  :id,
                  :path,
                  :title,
                  to_date(:created_at,'YYYY-MM-DD'), 
                  :author,
                  :platform,
                  :code)";

            //$stmt = $this->db->prepare($sql);
            $result = oci_parse($this->db, $sql);
            oci_bind_by_name($result, ":id", $id, 200);
            oci_bind_by_name($result, ":path", $path, 200);
            oci_bind_by_name($result, ":title", $title, 200);
            oci_bind_by_name($result, ":created_at", $created_at, 200);
            oci_bind_by_name($result, ":author", $author, 200);
            oci_bind_by_name($result, ":platform", $platform, 200);
            oci_bind_by_name($result, ":code", $code, 4000);
            oci_execute($result);

        } catch (PDOException $e) {

           $this->log("Trying  to insert ". json_encode($obj) ." on DB " . $e->getMessage(), "Error:" );
        } catch (Exception $e) {

            $this->log("General Error  " . $e->getMessage() . "\n \t\t\t Debug: " .json_encode($e), "Critical:");
        }
    }

    /**
     * Verify if a exploit exists on database
     * @param  int $id : exploitdb id  to check 
     * @return True  if  exists this id on database
     */
    private function exists_exploit($id) {

        try {

            $sth = "SELECT COUNT(ID) FROM exploits WHERE id = :id";
            oci_bind_by_name($sth, ":id", $id, 200);
            $result = oci_parse($this->db, $sth);
            oci_execute($result);
            while (oci_fetch_array($result)) {
              $nr_exploits= oci_result($result, 'COUNT(ID)');
            }
            if($nr_exploits = 0) return false;
            else return true;

        } catch (PDOException $e) {
            $this->log("Error checking if a exploit exists:  " . $e->getMessage() );
            throw new Exception("Error checking if a exploit exists:  " . $e->getMessage(), 1);
        }
    }

    /**
     * Populate database from csv file that will be updated from an admin script;
     */
    public function populate_db() {
        global $new_exploits;
        $exploits = array();
        if (($handle = fopen("C:\\Apache24\\htdocs\\exploitdbAPI\\files.csv", "r")) !== FALSE) {
          while (($data = fgetcsv($handle, 1000, ",")) !== FALSE) {
              if($data[6]='webapps'){ //we are only interested in web application exploits
              $exploit = array('id' => $data[0],
                            'path' => $data[1],
                            'title' => $data[2],
                            'date' => $data[3],
                            'author' => $data[4],
                            'platform' => $data[5]);
                if(!exists_exploit($id))
                  array_push($exploits, $exploit);
              }
          }
          fclose($handle);
        }
         $code = "";
         foreach($exploits as $exploit)
         {
            $id = $exploit['id'];
            $title = $exploit['title'];
            $date = $exploit['date'];
            $author = $exploit['author'];
            $platform = $exploit['platform'];
            $path = $exploit['path'];
            $code = "";
            $myfile = fopen($path, "r");
            while(!feof($myfile)) {
              $code = $code . fgets($myfile) . "<br>";
              if(strlen($code) > 3850) break;
          }
          fclose($myfile);
          if(strlen($code) > 1)
          {
            $this->new_exploits = true;
            insert_exploit($db, $id, $path, $title, $date, $author, $platform, $code);
          }
        }
        //call controller that sends email if the new_exploits flag has been set to true
        if($this->new_exploits)
        {
          $email_controller = new Email_Controller();
          $email_controller->send_mail();
        }
    }

    /** destruction garbage collection  */
    function  destruct()
    {
        oci_close($this->db);
    }

    /**
     * Auxiliary funciton to do a HTTP GET Request to a URL
     * @param  String $url URL to GeT
     * @return HTML string
     */
    private function request($url) {

        $curl = curl_init();
        // Set some options - we are passing in a useragent too here
        curl_setopt_array($curl, array(
            CURLOPT_RETURNTRANSFER => 1,
            CURLOPT_URL => "$url",
            CURLOPT_VERBOSE => 0,
            CURLOPT_HEADER => 1,
            CURLOPT_ENCODING => 1,
            CURLOPT_USERAGENT => 'Nstalker'
        ));

        // Send the request & save response to $resp
        $resp = curl_exec($curl);
        // Close request to clear up some resources
        $header_size = curl_getinfo($curl, CURLINFO_HEADER_SIZE);
        $this->header = substr($response, 0, $header_size);
        curl_close($curl);
        return $resp;
    }


    /**
     * @session Search
     *functon to search  o database
     * */
    /**
    * Search  a Exploit by Title
    * @param    STRING $pattern a pattern to search on title of exploit
    * @return   JSON   
    */
    
    public function byTitle($pattern)
    {
      try {

          (string) (trim(rtrim($pattern)));
          
          $sth = "SELECT * FROM exploits WHERE title LIKE '%$pattern%'";
          $result = oci_parse($this->db, $sth);
          oci_execute($result);
          oci_fetch_all($result, $resulted_obj);
           
          return json_encode($resulted_obj) ;

          
      } catch (PDOException $e) {

          die("Error:" . $e->getMessage() . "\n");
      }
    }
    //*** END of Search Session  ***/

    /**
     * Simle funtion to count how many exploits are on DB
     * @return INT 
     */
    public function count_exploits()
    {

      try {
            $sth = "SELECT count(id) FROM exploits";
            $result = oci_parse($this->db, $sth);
            oci_execute($result);
            while (oci_fetch_array($result)) {
              $nr_exploits= oci_result($result, 'COUNT(ID)');
            }
            return $nr_exploits;
        } catch (PDOException $e) {

            $this->log("$e->getMessage()", "Error");
                    
            die("Error: " . $e->getMessage() . "\n");
        }

    }

    /**
     * This is a simple function to log activities
     * @todo  integrate it with  unix syslog
     */
    public function log($message, $type = "info ") {
        
        $content = date("Y-m-d H:i:s") . " - " . $type . ": - " . $message . "\n";
        
        if($this->preserv_log == 1)
        {
            try {
                fwrite($this->fh_log, $content);
                
            } catch (Exception $ex) {
                echo "Error: ". $ex->getMessage()."\n";
            }
        }
        else{
            echo $content; 
        }
    }

}